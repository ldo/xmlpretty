#!/usr/bin/python3
#+
# Prettyprint XML read from stdin to stdout. Invoke this script
# something like:
#
#     xmlpretty <in.xml >out.xml
#
# or
#
#     xmlpretty <in.xml | more
#
# or
#
#     xml-generating-command | xmlpretty | less
#
# Anyway, you get the idea.
#
# It reads XML from standard input (e.g. a blob generated by
# xml.etree.ElementTree) and outputs it in a more readable form, with
# tags and attributes on separate lines and nicely indented, to
# standard output.
#
# Copyright 2015 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY <http://creativecommons.org/licenses/by/4.0/>.
#-

import sys
from xml.etree import \
    ElementTree as XMLElementTree
from xml.sax.saxutils import \
    escape, \
    quoteattr

out = sys.stdout

sol = True
def write_line(indent, line, newline = True) :
    global sol
    if sol :
        out.write(" " * indent * 4)
    #end if
    out.write(line)
    if newline :
        out.write("\n")
    #end if
    sol = newline
#end write_line

def end_line() :
    global sol
    if not sol :
        out.write("\n")
        sol = True
    #end if
#end end_line

def format(tag, indent) :
    write_line(indent, "<{}".format(tag.tag), newline = False)
    got_attr = False
    for attr in sorted(tag.keys()) :
        if not got_attr :
            end_line()
            got_attr = True
        #end if
        write_line(indent + 1, "{attr}={value}".format(attr = attr, value = quoteattr(tag.get(attr))))
    #end for
    if len(tag) != 0 :
        write_line(indent, ">")
        for child in tag :
            format(child, indent + 1)
        #end for
        write_line(indent, "</{}>".format(tag.tag))
    elif tag.text != None :
        write_line(indent, ">")
        write_line(indent + 1, escape(tag.text.strip()))
        write_line(indent, "</{}>".format(tag.tag))
    else :
        write_line(indent, "/>")
    #end if
#end format

doc = XMLElementTree.fromstring(sys.stdin.read())
format(doc, 0)
